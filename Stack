#include <stdio.h>
#include <stdlib.h>

typedef struct Node 
{
    int data;
    struct Node *next;
} Node;

typedef struct 
{
    Node *top;
} Stack;

void init(Stack *s)
{
    s->top = NULL;
}

int isEmpty(Stack *s)
{
    return s->top == NULL;
}

void push(Stack *s)
{
    int val;
    printf("Enter value to push: ");
    scanf("%d", &val);

    Node *newNode = (Node *)malloc(sizeof(Node));
    if (!newNode) 
    {
        printf("Memory allocation failed!\n");
        return;
    }

    newNode->data = val;
    newNode->next = s->top;
    s->top = newNode;

    printf("%d pushed onto stack.\n", val);
}

void pop(Stack *s)
{
    if (isEmpty(s)) 
    {
        printf("Stack Underflow! Cannot pop.\n");
        return;
    }

    Node *temp = s->top;
    printf("Popped element: %d\n", temp->data);
    s->top = temp->next;
    free(temp);
}

void peek(Stack *s)
{
    if (isEmpty(s)) 
    {
        printf("Stack is empty.\n");
        return;
    }

    printf("Top element: %d\n", s->top->data);
}

void display(Stack *s)
{
    if (isEmpty(s)) 
    {
        printf("Stack is empty.\n");
        return;
    }

    printf("Stack elements (top â†’ bottom): ");
    Node *temp = s->top;
    while (temp) 
    {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

void size(Stack *s)
{
    int count = 0;
    Node *temp = s->top;
    while (temp) 
    {
        count++;
        temp = temp->next;
    }
    printf("Current stack size: %d\n", count);
}

void search(Stack *s)
{
    if (isEmpty(s)) 
    {
        printf("Stack is empty.\n");
        return;
    }

    int val, pos = 1;
    printf("Enter element to search: ");
    scanf("%d", &val);

    Node *temp = s->top;
    while (temp) 
    {
        if (temp->data == val) 
        {
            printf("%d found at position %d from top.\n", val, pos);
            return;
        }
        temp = temp->next;
        pos++;
    }

    printf("%d not found in stack.\n", val);
}

void clearStack(Stack *s)
{
    Node *temp;
    while (s->top) 
    {
        temp = s->top;
        s->top = s->top->next;
        free(temp);
    }
    printf("Stack cleared successfully.\n");
}

int main()
{
    Stack s;
    init(&s);
    int choice;

    do {
        printf("\n--- Stack using Linked List ---\n");
        printf("1. Push\n2. Pop\n3. Peek\n4. Display\n5. Check if Empty\n");
        printf("6. Size\n7. Search\n8. Clear Stack\n0. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1: 
                push(&s); 
                break;
            case 2: 
                pop(&s); 
                break;
            case 3: 
                peek(&s); 
                break;
            case 4: 
                display(&s); 
                break;
            case 5: 
                printf(isEmpty(&s) ? "Stack is empty.\n" : "Stack is not empty.\n"); 
                break;
            case 6: 
                size(&s); 
                break;
            case 7: 
                search(&s); 
                break;
            case 8: 
                clearStack(&s); 
                break;
            case 0: 
                printf("Exiting...\n"); 
                break;
            default: 
                printf("Invalid choice!\n");
        }

    } while (choice != 0);

    return 0;
}
/*
 * Stack using Array with Menu-Driven Operations
 * Supports: Push (single/multiple), pop, peek, search,
 *           display stack. Uses dynamic array with resizing.
 */

#include <stdio.h>
#include <stdlib.h>

int *stack = NULL;
int top = -1;
int capacity = 0;

void display();
void push(int value);
void pop();
int peek();
void searchValue(int value);
void pushSingle();
void pushMultiple();
void resizeStack();

int main() {
    int choice;

    while (1) {
        printf("\n=== Stack Menu (Array-Based) ===\n");
        printf("1. Push Single Value\n");
        printf("2. Push Multiple Values\n");
        printf("3. Pop\n");
        printf("4. Peek (Top)\n");
        printf("5. Search Value\n");
        printf("6. Display Stack\n");
        printf("7. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                pushSingle();
                break;
            case 2:
                pushMultiple();
                break;
            case 3:
                pop();
                break;
            case 4:
                if (top == -1) {
                    printf("Stack is empty!\n");
                } else {
                    printf("Top element: %d\n", peek());
                }
                break;
            case 5:
                if (top == -1) {
                    printf("Stack is empty!\n");
                } else {
                    int val;
                    printf("Enter value to search: ");
                    scanf("%d", &val);
                    searchValue(val);
                }
                break;
            case 6:
                display();
                break;
            case 7:
                free(stack);
                printf("Memory freed. Exiting...\n");
                exit(0);
            default:
                printf("Invalid choice! Try again.\n");
        }
    }
    return 0;
}

void resizeStack() {
    if (capacity == 0) capacity = 1;
    else capacity *= 2;
    stack = (int*)realloc(stack, capacity * sizeof(int));
    if (stack == NULL) {
        printf("Memory allocation failed!\n");
        exit(1);
    }
}

void push(int value) {
    if (top + 1 == capacity) resizeStack();
    stack[++top] = value;
}

void pop() {
    if (top == -1) {
        printf("Stack is empty! Cannot pop.\n");
        return;
    }
    printf("Popped %d from stack.\n", stack[top--]);
}

int peek() {
    if (top == -1) return -1;
    return stack[top];
}

void display() {
    if (top == -1) {
        printf("Stack is empty!\n");
        return;
    }
    printf("Stack (top to bottom): ");
    for (int i = top; i >= 0; i--) {
        printf("%d ", stack[i]);
    }
    printf("\n");
}

void searchValue(int value) {
    int found = 0;
    printf("Searching for %d: ", value);
    for (int i = top; i >= 0; i--) {
        if (stack[i] == value) {
            if (!found) printf("Found at position(s) from top: ");
            printf("%d ", top - i);
            found = 1;
        }
    }
    if (!found) printf("Not found.\n");
    else printf("\n");
}

void pushSingle() {
    int value;
    printf("Enter value to push: ");
    scanf("%d", &value);
    push(value);
    printf("Value %d pushed to stack.\n", value);
}

void pushMultiple() {
    int n, i, value;
    printf("How many values to push? ");
    scanf("%d", &n);
    if (n <= 0) {
        printf("Number must be positive!\n");
        return;
    }
    for (i = 0; i < n; i++) {
        printf("Enter value %d: ", i + 1);
        scanf("%d", &value);
        push(value);
    }
    printf("%d values pushed to stack.\n", n);
}
#include <stdio.h>
#include <stdlib.h>
#define MAX 5

typedef struct 
{
    int arr[MAX];
    int front;
    int rear;
} Queue;

void init(Queue *q)
{
    q->front = -1;
    q->rear = -1;
}

int isEmpty(Queue *q)
{
    return (q->front == -1);
}


int isFull(Queue *q)
{
    return (q->rear == MAX - 1);
}

void enqueue(Queue *q)
{
    if (isFull(q))
    {
        printf("Queue is full.\n");
        return;
    }

    int data;
    printf("Enter data to enqueue: ");
    scanf("%d", &data);

    if (isEmpty(q))
    {
        q->front = 0;
    }

    q->rear++;
    q->arr[q->rear] = data;
    printf("%d enqueued.\n", data);
}

void dequeue(Queue *q)
{
    if (isEmpty(q))
    {
        printf("Queue is empty.\n");
        return;
    }

    int data = q->arr[q->front];
    printf("%d dequeued.\n", data);
    q->front++;

    if (q->front > q->rear)
    {
        q->front = q->rear = -1; // Reset when empty
    }
}


void peek(Queue *q)
{
    if (isEmpty(q))
    {
        printf("Queue is empty.\n");
        return;
    }

    printf("Front element: %d\n", q->arr[q->front]);
}

void display(Queue *q)
{
    if (isEmpty(q))
    {
        printf("Queue is empty.\n");
        return;
    }

    printf("Queue elements: ");
    for (int i = q->front; i <= q->rear; i++)
    {
        printf("%d ", q->arr[i]);
    }
    printf("\n");
}

void size(Queue *q)
{
    if (isEmpty(q))
    {
        printf("Size: 0\n");
        return;
    }

    printf("Current size: %d\n", q->rear - q->front + 1);
}

void search(Queue *q)
{
    if (isEmpty(q))
    {
        printf("Queue is empty.\n");
        return;
    }

    int key, found = 0;
    printf("Enter element to search: ");
    scanf("%d", &key);

    for (int i = q->front; i <= q->rear; i++)
    {
        if (q->arr[i] == key)
        {
            printf("Element %d found at position %d.\n", key, i - q->front + 1);
            found = 1;
            break;
        }
    }

    if (!found)
        printf("Element not found.\n");
}

void clear(Queue *q)
{
    q->front = -1;
    q->rear = -1;
    printf("Queue cleared.\n");
}

int main()
{
    Queue q;
    init(&q);
    int choice;

    do
    {
        printf("\n1] Enqueue\n2] Dequeue\n3] Peek\n4] Display\n5] Size\n6] Search\n7] Clear\n0] Exit\n");
        scanf("%d", &choice);

        switch (choice)
        {
            case 1: 
                enqueue(&q); 
                break;

            case 2: 
                dequeue(&q); 
                break;

            case 3: 
                peek(&q); 
                break;

            case 4: 
                display(&q); 
                break;

            case 5: 
                size(&q); 
                break;

            case 6: 
                search(&q); 
                break;

            case 7: 
                clear(&q); 
                break;

            case 0: 
                printf("Exiting...\n"); 
                break;

            default: 
                printf("Invalid choice.\n"); 
                break;
        }
    } 
    while (choice != 0);

    return 0;
}
